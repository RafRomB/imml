import networkx as nx
import pandas as pd
from sklearn.base import BaseEstimator, ClassifierMixin
from sklearn.cluster import KMeans

from ._msne._aux_msne import Embedding
from ._msne.based import similarity
from imvc.utils import check_Xs


class MSNE(BaseEstimator, ClassifierMixin):
    r"""
    Multiple Similarity Network Embedding (MSNE).

    Created originally as a partial multi-omics integrative method for cancer subtyping, MSNE integrates the
    multi-views information by embedding the neighbor relations of samples defined by the random walk on multiple
    similarity networks.

    Parameters
    ----------
    n_clusters : int, default=None
        The number of clusters to generate.
    k : int (default=20)
        The top k neighborhoods of each node will be treated as local neighbors.
    walk_length : int (default=20)
        The length of sequences generated by random walk on multiple networks.
    num_walks : int (default=100)
        Starting with each node, MSNE will generate 'num_walks' sequences.
    embed_size : int (default=100)
        The dimension of embedding vectors.
    window_size : int (default=10)
        The window_size in skip-gram.
    random_state : int, default=None
        Determines the randomness. Use an int to make the randomness deterministic.
    verbose : bool, default=False
        Verbosity mode.
    n_jobs : int (default=1)
        The number of jobs to run in parallel. None means 1 unless in a joblib.parallel_backend context. -1 means
        using all processors.
.
    Attributes
    ----------
    labels_ : array-like of shape (n_samples,)
        Labels of each point in training data.
    embedding_ : array-like of shape (n_samples, embed_size)
        Representation of embedding vectors to be used as input for the KMeans clustering step.

    References
    ----------
    .. [#msnepaper] Xu, H., Gao, L., Huang, M., and Duan, R. (2021). A network embedding based method for partial
                    multi-omics integration in cancer subtyping. Methods. 192, 67â€“76. doi: 10.1016/j.ymeth.2020.08.001.
    .. [#msnecode] https://github.com/GaoLabXDU/MSNE

    Example
    --------
    >>> from sklearn.pipeline import make_pipeline
    >>> from imvc.datasets import LoadDataset
    >>> from sklearn.preprocessing import StandardScaler
    >>> from imvc.preprocessing import MultiViewTransformer
    >>> from imvc.cluster import MSNE
    >>> Xs = LoadDataset.load_dataset(dataset_name="nutrimouse")
    >>> normalizer = StandardScaler().set_output(transform="pandas")
    >>> estimator = MSNE(n_clusters = 3)
    >>> pipeline = make_pipeline(MultiViewTransformer(normalizer), estimator)
    >>> labels = pipeline.fit_predict(Xs)
    """

    def __init__(self, n_clusters: int = 8, k: int = 20, walk_length: int = 20, num_walks: int = 100,
                 embed_size: int = 100, window_size: int = 10, random_state: int = None, verbose: bool = False,
                 n_jobs: int = 1):
        if not isinstance(n_clusters, int):
            raise ValueError(f"Invalid n_clusters. It must be an int. A {type(n_clusters)} was passed.")
        if n_clusters < 2:
            raise ValueError(f"Invalid n_clusters. It must be an greater than 1. {n_clusters} was passed.")

        self.window_size = window_size
        self.embed_size = embed_size
        self.num_walks = num_walks
        self.walk_length = walk_length
        self.k = k
        self.n_clusters = n_clusters
        self.random_state = random_state
        self.verbose = verbose
        self.n_jobs = n_jobs


    def fit(self, Xs, y=None):
        r"""
        Fit the transformer to the input data.

        Parameters
        ----------
        Xs : list of array-likes
            - Xs length: n_views
            - Xs[i] shape: (n_samples, n_features_i)
            A list of different views.
        y : array-like, shape (n_samples,)
            Labels for each sample. Only used by supervised algorithms.

        Returns
        -------
        self :  returns an instance of self.
        """
        Xs = check_Xs(Xs, force_all_finite='allow-nan')
        try:
            assert self.k < len(Xs[0])
        except AssertionError:
            raise ValueError(f"Invalid k. It must be smaller than the number of samples {len(Xs[0])}."
                             f" {self.k} was passed.")
        S = []

        if not isinstance(Xs[0], pd.DataFrame):
            Xs = [pd.DataFrame(X) for X in Xs]
        for X in Xs:
            s = similarity(X, k=self.k)
            S.append(nx.DiGraph(s.values))
        if self.verbose:
            print("construct similarity networks finished")
        model = Embedding(S, workers=self.n_jobs, verbose=self.verbose, random_state=self.random_state)
        model.sample_sentence(walk_length=self.walk_length, num_walks=self.num_walks)
        if self.verbose:
            print("sample sequences finished")
        model.train(embed_size=self.embed_size, window_size=self.window_size, epoch=5)
        embeddings = model.get_embeddings()
        self.labels_ = KMeans(n_clusters=self.n_clusters, n_init="auto", verbose=self.verbose,
                              random_state=self.random_state).fit_predict(embeddings)
        self.embedding_ = embeddings
        return self


    def _predict(self, Xs):
        r"""
        Return clustering results for samples.

        Parameters
        ----------
        Xs : list of array-likes
            - Xs length: n_views
            - Xs[i] shape: (n_samples, n_features_i)
            A list of different views.

        Returns
        -------
        labels : list of array-likes, shape (n_samples,)
            The predicted data.
        """
        labels = self.labels_
        return labels


    def fit_predict(self, Xs, y=None):
        r"""
        Fit the model and return clustering results.
        Convenience method; equivalent to calling fit(X) followed by predict(X).

        Parameters
        ----------
        Xs : list of array-likes
            - Xs length: n_views
            - Xs[i] shape: (n_samples, n_features_i)
            A list of different views.

        Returns
        -------
        labels : ndarray, shape (n_samples,)
            The predicted data.
        """

        labels = self.fit(Xs)._predict(Xs)
        return labels
